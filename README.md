## SpringCloud 学习示例项目

---

### 微服务特点

- 按业务划分为一个独立运行的程序，即服务单元
- 服务之间通过 http 协议通信
- 自动化部署
- 可用不同的编程语言
- 可用不同的存储技术
- 服务集中化管理
- 微服务是一个分布式系统
### 微服务“微”
- 代码量
- 开发时间长短
- 业务大小
### CAP
- C（Consistency  一致性）：数据写入成功，之后读取读到的都是写入后的数据
- A（Availability  可用性）：服务的可用性
- P（Partition-tolerance  分区容错性）：单台或多台服务出现问题后，其他正常的服务仍可以正常提供服务
### 微服务具有的功能
- 服务的注册和发现
- 服务的负载均衡
- 服务的容错
- 服务的网关
- 服务配置的统一管理
- 链路追踪
- 实时日志
### Zookeeper和Eureka
||Zookeeper|Eureka|
|---|---|---|
|CAP|满足CP |满足AP|
|服务注册|当 master 节点 down 掉，剩余节点会重新选举 leader ，耗时30~120s，选取期间整个集群不可用，服务瘫痪|各个节点平等，当请求一个节点失败时会自动切换至另一个节点，但是不保证各个节点的强一致性 Eureka 还有一种自我保护机制，如果在 15 分钟内超过 85% 的节点都没有正常的心跳，那么 Eureka 就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： 1.Eureka 不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 2. Eureka 仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用) 3.当网络稳定时，当前实例新的注册信息会被同步到其它节点中|

### 负载均衡

- 将负载分摊到多个执行单元上，常见的两种方式

> - 独立进程单元，通过负载均衡策略，将请求发送到不同的执行单元上，例如 Nginx
> - 将负载均衡以代码逻辑的形式封装到服务消费者的客户端上，服务消费者维护了一份服务提供者的信息列表，通过负载均衡策略将请求分摊给多个服务提供者

### Feign

- 简化 Java Http 客户端远程调用
- Feign 采用的是http网络交互，可以采用`feign-httpclient`或者`okhttp`做网络请求框架，只需要在pom中添加相关依赖即可。
- Feign中负载均衡也是通过Ribbon来实现的。
- Feign请求过程

  1. 通过 @EnableFeignClients 注解开启FeignClient功能；
  2. 根据Feign的规则实现接口，并在接口上面加上 @FeignClient 注解；
  3. 程序启动自动扫描 @FeignClient 注解的类，并注入到IoC容器；
  4. 当接口的方法被调用时，通过JDK代理生成具体的 requestTemplate 对象，生成 http 请求的 request 对象；
  5. 将 request 对象交给 Client 去处理，可以使用 HttpUrlConnection 、HttpClient 或 OkHttp；
  6. 最后 Client 被封装到 LoadBalanceClient 类，这个类结合 Ribbon 实现负载均衡。
- Feign 可以直接配置 Hystrix 熔断器

### Hystrix

- 通过隔离服务的访问点组织联动故障，提供故障的解决方案，提高整个分布式系统的弹性

- #### 设计原则

> - 防止单个服务的故障耗尽整个那个服务的 Servlet 容器的线程资源
> - 快速失败机制，当某个服务出现故障，则调用该服务的线程快速失败而不是线程等待
> - 提供回退方案，请求发生故障时，按照提供的方案回退
> - 使用熔断机制，防止故障扩大影响到其他服务
> - 利用监控组件实时监控熔断器的状态

- #### Hystrix工作机制

> - 当某个API服务在一定时间内失败的次数大于设定阀值，触发熔断器打开，这时请求该API服务的接口会执行快速失败逻辑（即回退方案）。
> - 处于打开状态的熔断器，一段时间后，会处于半打开半关闭状态，将一定数量的请求执行正常逻辑，剩余的请求执行快速失败逻辑，如果执行正常逻辑的请求失败了，则熔断器继续打开，如果成功了，则熔断器关闭。

- #### 测试

> 执行请求中，断开两个服务提供方的其中一个，在短时间内的请求上仍然可以负载到 done 掉的服务上。在停止两个服务提供方后则会执行 fallback 配置的方法。